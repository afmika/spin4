use crate::mat::{Mat2x4, Mat4x1, Mat4x4};
use crate::sys_types::{BinOperator, InOut, InOutType, PointerDir, Reg, Stack};
use anyhow::Result;
use std::io::{self, Read};

pub struct System {
  /// Encodes the 4D space state
  pub core: Mat4x4,
  pub acc_x: i32,
  pub acc_y: i32,
  pub stack: Stack
}

impl System {
    pub fn new() -> Self {
        Self {
            core: Mat4x4::identity(),
            acc_x: 0,
            acc_y: 0,
            stack: Stack {
                dir: PointerDir::Right,
                items: vec![]
            }
        }
    }

    /// Update the core tensor `Core <- Rot * Core` and the accumulator registers
    pub fn apply(&mut self, rot: Mat4x4, op: BinOperator) -> Result<()> {
        self.core = rot.clone() * self.core;
        let pair = self.active_plane_signature();
        self.apply_signature(pair, &op)?;
        Ok(())
    }

    /// Determine each register's `increment signature`
    /// by projecting the only congruent plane's basis vectors to the initial plane generated by `A * (1 0 0 0)^T + B * (0 1 0 0)^T`
    /// then retrieve their signs.
    fn active_plane_signature(&self) -> (i8, i8) {
        // current state
        let t = self.core;
        // filter matrix
        let f = Mat2x4::new(
            1, 0, 0, 0,
            0, 1, 0, 0
        );
        // scanner matrix
        let s = Mat4x1::new(
            1, 
            1, 
            1,
            1
        );
        // Since t is guaranteed to be a modified permutation matrix with entries -1, 0, 1
        // 1. t * s will always return a vector whose entries are exactly the non zero values
        //    of the permuted columns.
        // 2. f filters the first two rows of the resulting 4D vector 
        let ret = f * (t * s);
        (ret[0], ret[1]) 
    }

    fn apply_signature(&mut self, (x, y): (i8, i8), op: &BinOperator) -> Result<()> {
        self.acc_x = op.compute(self.acc_x, x as i32)?;
        self.acc_y = op.compute(self.acc_y, y as i32)?;
        Ok(())
    }

    pub fn push_acc_op(&mut self, op: BinOperator) -> Result<()> {
        let value = op.compute(self.acc_x, self.acc_y)?;
        self.stack.items.push(value);
        Ok(())
    }

    pub fn push_from(&mut self, reg: Reg) {
        let new_top = match reg {
            Reg::X => self.acc_x,
            Reg::Y => self.acc_y,
        };
        self.stack.items.push(new_top);
    }

    pub fn pop_to(&mut self, reg: Reg) {
        self.stack
            .items
            .pop()
            .and_then(|value| -> Option<i32> {
                match reg {
                    Reg::X => { self.acc_x = value },
                    Reg::Y => { self.acc_y = value },
                }
                None
            });
    }

    pub fn rotate_stack(&mut self, dir: PointerDir) {
        match dir {
            PointerDir::Left => self.stack.items.rotate_left(1),
            PointerDir::Right => self.stack.items.rotate_right(1),
        }
    }

    pub fn process_io(&mut self, interf: InOut, tpe: InOutType) -> Result<()> {
        match interf {
            InOut::Stdin => {
                let value = match tpe {
                    InOutType::Char => {
                        let mut buffer = [0 as u8; 1];
                        io::stdin().read_exact(&mut buffer)?;
                        buffer[0] as i32
                    },
                    InOutType::Num => {
                        let mut buffer = String::new();
                        io::stdin().read_line(&mut buffer)?;
                        buffer.trim().parse::<i32>()?
                    }
                };
                self.stack.items.push(value);
            },
            InOut::Stdout =>{
                self.stack
                    .items
                    .last()
                    .and_then(|top| -> Option<i32> {
                        let top = match tpe {
                            InOutType::Char => format!("{}", (top & 0xff) as u8 as char),
                            InOutType::Num => format!("{}", top.to_owned())
                        };
                        print!("{top}");
                        None
                    });
            },
        }
        Ok(())
    }

    pub fn display(&self) {
        println!("Final stack {:?}", self.stack.items);
        println!("Final acc {:?}", &[self.acc_x, self.acc_y]);
        println!("Core tensor");
        for (i, item) in self.core.transpose().iter().enumerate() {
            print!("{}", if i % 4 == 0 && i != 0 { '\n' } else { ' ' });
            print!("{}", if item >= &0 { format!( " {item}") } else { item.to_string() });
        }
    }
}
